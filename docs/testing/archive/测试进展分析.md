# 以太网 MAC RGMII AXI 测试进展分析

## 📊 当前状态

### ✅ 重大突破！

**第一次 AXI-Lite 操作成功了！**

```
[235000] AXI-Lite Write: Addr=0x0008, Data=0x12345678  ← 写成功
[305000] AXI-Lite Read: Addr=0x0008, Data=0x12345678   ← 读成功
PASS: MAC地址低32位正确                                 ← 验证通过！
```

这证明：
- ✅ AXI-Lite 握手修复成功
- ✅ eth_mac_axil_regs 模块工作正常
- ✅ 寄存器读写功能基本可用

### ⚠️ 新发现的问题

第二次操作时卡住：

```
[345000] AXI-Lite Write: Addr=0x0000, Data=0x0000000f  ← 写成功
ERROR: 仿真超时！                                       ← 读操作卡住
```

## 🔍 问题分析

### 时间线

1. **t=235000**: 第一次写 (地址 0x0008) ✅
2. **t=305000**: 第一次读 (地址 0x0008) ✅
3. **t=345000**: 第二次写 (地址 0x0000) ✅
4. **t=????**: 第二次读 (地址 0x0000) ❌ 卡住

### 问题定位

从测试代码可以看出：
```verilog
// 写入控制寄存器
axil_write(16'h0000, 32'h0000000F); // 成功
#50;

// 读回验证
axil_read(16'h0000, read_data);     // 在这里卡住
```

**结论**：
- `axil_write` 已修复，工作正常
- `axil_read` 可能在第一次偶然工作，但第二次失败
- 或者是读操作的握手逻辑仍有问题

## 🛠️ 技术细节

### AXI-Lite 握手模式

从 `eth_mac_axil_regs.v` 的实现可以看出：

**写操作（已修复）**：
1. Master 发起 AWVALID + WVALID
2. Slave 先响应 AWREADY（接收地址）
3. 然后响应 WREADY（接收数据）
4. 最后发送 BVALID（写响应）

**读操作（可能需要修复）**：
1. Master 发起 ARVALID
2. Slave 响应 ARREADY（接收地址）
3. Slave 发送 RVALID + RDATA（读数据）
4. Master 响应 RREADY（接收数据）

### eth_mac_axil_regs 读逻辑

```verilog
// 读地址通道
assign s_axil_arready = !read_addr_valid_reg;

always @(posedge clk) begin
    if (s_axil_arvalid && s_axil_arready) begin
        read_addr_reg <= s_axil_araddr;
        read_addr_valid_reg <= 1'b1;
    end else if (read_data_valid_reg && s_axil_rready) begin
        read_addr_valid_reg <= 1'b0;
    end
end

// 读数据通道
assign s_axil_rvalid = read_data_valid_reg;

always @(posedge clk) begin
    if (read_addr_valid_reg && !read_data_valid_reg) begin
        read_data_valid_reg <= 1'b1;
        // ... 读取寄存器数据
    end else if (read_data_valid_reg && s_axil_rready) begin
        read_data_valid_reg <= 1'b0;
    end
end
```

**关键点**：
- `read_data_valid_reg` 必须在读完成后清除
- 如果第一次读之后没有正确清除，第二次读会卡住

## 📈 进展评估

### 总体进度：40% → 60%

- ✅ 编译成功 (100%)
- ✅ 仿真启动 (100%)
- ✅ AXI-Lite 写操作 (100%)
- 🔄 AXI-Lite 读操作 (50% - 第一次成功，第二次失败)
- ⏳ 功能测试 (0% - 等待基础操作完善)

### 成就解锁

- 🏆 **首次成功的寄存器读写**
- 🏆 **AXI-Lite 握手修复方法验证**
- 🏆 **从超时到部分通过**

## 🎯 下一步行动

### 优先级 1：修复 axil_read 任务

可能的问题：
1. 读完成后 rready 没有正确清除
2. 读操作后需要额外的延迟
3. 状态机需要时间返回空闲状态

建议的修复：
```verilog
task axil_read;
    input [AXIL_ADDR_WIDTH-1:0] addr;
    output [AXIL_DATA_WIDTH-1:0] data;
    begin
        @(posedge logic_clk);
        s_axil_araddr = addr;
        s_axil_arprot = 3'b000;
        s_axil_arvalid = 1'b1;
        s_axil_rready = 1'b1;
        
        // 等待地址握手
        wait(s_axil_arready);
        @(posedge logic_clk);
        s_axil_arvalid = 1'b0;
        
        // 等待数据
        wait(s_axil_rvalid);
        data = s_axil_rdata;
        @(posedge logic_clk);
        s_axil_rready = 1'b0;
        
        // 额外的清理周期
        @(posedge logic_clk);  // 新增
        
        $display("[%0t] AXI-Lite Read: Addr=0x%04x, Data=0x%08x", $time, addr, data);
    end
endtask
```

### 优先级 2：增加调试输出

在 testbench 中添加更多信息：
```verilog
$display("[DEBUG] Before read: arready=%b, rvalid=%b", s_axil_arready, s_axil_rvalid);
```

### 优先级 3：简化测试

先测试连续的读或写操作：
- 连续 3 次写操作
- 连续 3 次读操作
- 然后再混合读写

## 💡 经验总结

### 已验证的经验

1. **Icarus Verilog 完全可用**
   - 不需要 Verilator
   - 完美支持现有 testbench

2. **顺序握手模式**
   - AXI-Lite 写：先地址，后数据
   - 这是 `eth_mac_axil_regs` 的实现方式

3. **调试方法有效**
   - 查看输出日志
   - 分析时间戳
   - 逐步定位问题

### 待验证的假设

1. 读操作可能需要额外的恢复时间
2. 状态机清理可能需要一个周期
3. 连续操作可能需要间隔

## 📝 结论

**当前状态**：🟢 取得重大进展！

从完全失败到：
- ✅ 1/1 写操作成功
- ✅ 1/2 读操作成功
- 🔄 总体测试 50% 完成

这是巨大的进步！只需要微调读操作的时序，就可以完成基础的寄存器访问测试。

**预计完成时间**：15-30分钟

